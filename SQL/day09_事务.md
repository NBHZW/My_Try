# day 09---事务

## 什么是事务

事务用于保证数据的一致性,它由一组相关的 DML 语句组成,该组的 DML 语句

要么全部成功 要么全部失败 

例如:转账功能	A转钱给B  则A要减少钱  B要增加钱  那么A减少的这个语句要执行成功,B加钱的语句也要成功 ;  或者A减少和B增加这两个功能都要运行失败不能出现两者部分失败 部分成功   所以要将多个语句当作整体  用于保持数据一致性



## 事务和锁

当执行事务的时候, MySQL 会给表上加锁,防止其他用户修改表中数据

## 控制事物的重要操作语句

START TRANSACTION		开始一个事务

SAVEPOINT 保存点名字		  设置保存点

ROLLBACK TO 保存点名字	  回退事务到某个保存点

ROLLBACK								回退全部事务

COMMIT									提交事务,所有的操作生效,不能回退  

commit也就是结束事务  会自动删除保存点 释放锁  数据生效

## 事务的注意细节

(1)不开启事务的时候  DML语句是默认提交的(默认自动会commit的) 也就是说 只有在开始事务后,才能对其进行设置保存点  回退等操作  否则所有的DML 语句都默认为     开始事务 DML语句 结束提交事务

(2)开启事务后 如果你开启事务之后 没有设置保存点  也可以直接使用rollback  会回到你开启事务时的状态

(3)InnoDB存储引擎支持事务  但是 MyISAM不支持事务

(4)开启事务的方法不仅可以用start transaction  也可以使用 set autocommit=off

## 事务隔离级别

隔离级别和事务相关  所以谈论隔离级别一定要开启事务的前提



多个连接开启各自的事务,在操作数据库的时候,数据库系统负责隔离操作,以保证各个连接操作的时候的数据的准确性

如果没有隔离性,就会出现以下问题:

脏读

一个连接读取到了另外一个连接的的未提交操作  即写了DML操作 但是还没commit

不可重复读

同一查询在同一事务中多次进行,由于其他提交的事务所做的修改的或者删除的,每次返回不同的结果集,此时发生不可重复读取

例如:一个用户在十点钟连接该数据库,想要读取统计该数据库中的十点钟以前的数据,在统计的过程中,另外一个用户连接了该数据库,然后对信息进行了修改或者删除  导致数据库中的数据会进行变化 就会影响到前一个用户的工作

幻读

同一查询在同一事务中多次进行  由于其他提交事务所做的插入操作,每次返回不同的结果集,此时发生幻读

**主要有四种隔离级别**

可重复读 Repeatable read  为默认的隔离级别 

![image-20230622174239932](C:\Users\John\AppData\Roaming\Typora\typora-user-images\image-20230622174239932.png)

查看当前会话隔离级别语句:

SELECT @@TRANSACTION_ISOLATION

查看系统当前隔离级别

SELECT @@GLOBAL . TRANSACTION_ISOLATION

设置该控制台的隔离级别为

SET SESSION TRANSACTION ISOLATION LEVEL  隔离级别名

设置当前系统的隔离级别

SET GLOBAL TRANSACTION ISOLATION LEVEL  隔离级别名



## 演示

两个MySQL的连接   并且修改一个的隔离级别为 read-uncommitted(右边)  两个连接均开启事务   创建一个测试空表 isolation_test

![image-20230623142700554](C:\Users\John\AppData\Roaming\Typora\typora-user-images\image-20230623142700554.png)

在第一个连接(左边 不做隔离级别修改的A连接)中  给表加入一个数据但是***不提交***  然后再修改隔离级别后的B连接中select查看表中数据

结果发现竟然能查出来!!!!     ***这个就是脏读现象***

![image-20230623143250456](C:\Users\John\AppData\Roaming\Typora\typora-user-images\image-20230623143250456.png)

A连接中进行一个数据的修改 但是未提交  B连接查找却看得到  这个就是***不可重复读***

A连接中进行一个数据的增加 但是未提交 B连接查找却看得到  这个就是***幻读***

![image-20230623144356031](C:\Users\John\AppData\Roaming\Typora\typora-user-images\image-20230623144356031.png)

将上述操作全部提交之后  我们将B连接设置为  读已提交  的隔离级别

![image-20230623145320696](C:\Users\John\AppData\Roaming\Typora\typora-user-images\image-20230623145320696.png)

然后 我们在A中操作  添加一个新数据到表中但是不提交 

在A连接中使用select进行查询  我们能够查到新加入的数据 

但是在B中我们查询 却找不到我们刚刚加入的新数据

![image-20230623145656066](C:\Users\John\AppData\Roaming\Typora\typora-user-images\image-20230623145656066.png)

**为啥我们在最开始加入Jack的数据的时候  能在B连接中查看到**

**但是在这里我们加入Jerry的数据的时候B连接中却看不到了?**

因为我们第二次中设置的隔离标准是read committed  不会出现脏读现象了.

## 加锁读

我们演示的都是不加锁

不加锁就是   多个连接,某一个连接在操作的时候  可以不提交  其他连接的操作不受影响 

加锁就是   多个连接,某一个在操作的时候  这个连接最后一定要先commit之后  其他连接才能进行操作  否则就会卡在那里不动

相比较之下   加锁肯定是最安全最稳妥的  但是如果给所有的操作都加锁  必然导致开发效率降低  同样的   不加锁允许多连接同时操作 但是容易出现  幻读  不可重复度  脏读 等现象   各有利弊
